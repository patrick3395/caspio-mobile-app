---
phase: 02-data-service-enhancement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/pages/hud/hud-data.service.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "HudDataService emits cacheInvalidated$ events when data changes"
    - "Rapid sync events are batched via 1-second debounce (no UI thrashing)"
    - "Background refresh completion triggers cacheInvalidated$ emission"
    - "Photo sync clears caches but does NOT emit cacheInvalidated$ (race condition prevention)"
  artifacts:
    - path: "src/app/pages/hud/hud-data.service.ts"
      provides: "Cache invalidation Subject and debounced emission"
      contains: "cacheInvalidated$"
    - path: "src/app/pages/hud/hud-data.service.ts"
      provides: "Debounced invalidation method"
      contains: "debouncedCacheInvalidation"
    - path: "src/app/pages/hud/hud-data.service.ts"
      provides: "Comprehensive Dexie subscriptions"
      contains: "backgroundRefreshComplete$"
  key_links:
    - from: "src/app/pages/hud/hud-data.service.ts"
      to: "OfflineTemplateService.backgroundRefreshComplete$"
      via: "subscription in constructor"
      pattern: "offlineTemplate\\.backgroundRefreshComplete\\$\\.subscribe"
    - from: "src/app/pages/hud/hud-data.service.ts"
      to: "IndexedDbService.imageChange$"
      via: "subscription in constructor"
      pattern: "indexedDb\\.imageChange\\$\\.subscribe"
---

<objective>
Add cache invalidation Subject with debounced emission and comprehensive Dexie subscriptions to HudDataService

Purpose: Enable pages to subscribe to a single `cacheInvalidated$` event instead of managing multiple sync subscriptions. This matches the proven pattern from EngineersFoundationDataService.

Output: HudDataService with `cacheInvalidated$` Subject, `debouncedCacheInvalidation()` method, and subscriptions to ALL Dexie change sources (sync events, background refresh, image changes).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-service-enhancement/02-RESEARCH.md

# Source pattern to copy from:
@src/app/pages/engineers-foundation/engineers-foundation-data.service.ts (lines 36-204)

# Target file to modify:
@src/app/pages/hud/hud-data.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cacheInvalidated$ Subject and debounce infrastructure</name>
  <files>src/app/pages/hud/hud-data.service.ts</files>
  <action>
Add the following to HudDataService, copying exactly from engineers-foundation-data.service.ts:

1. **Add import for Subject** (already has Subscription imported):
   - Verify `Subject` is imported from 'rxjs' (add if missing)

2. **Add import for OfflineTemplateService**:
   ```typescript
   import { OfflineTemplateService } from '../../services/offline-template.service';
   ```

3. **Add properties after the existing cache declarations** (around line 44):
   ```typescript
   // Event emitted when caches are invalidated - pages should reload their data
   public cacheInvalidated$ = new Subject<{ serviceId?: string; reason: string }>();

   // Subscription array for cleanup (replaces individual syncSubscription/photoSyncSubscription)
   private syncSubscriptions: Subscription[] = [];

   // Debounce timer for cache invalidation to batch multiple sync events into one UI refresh
   private cacheInvalidationTimer: any = null;
   private pendingInvalidationServiceId: string | undefined = undefined;
   ```

4. **Inject OfflineTemplateService in constructor**:
   Add `private readonly offlineTemplate: OfflineTemplateService` to constructor parameters.

5. **Add debouncedCacheInvalidation method** (after unsubscribeFromSyncEvents):
   ```typescript
   /**
    * Debounced cache invalidation to batch multiple sync events into one UI refresh
    * This prevents rapid UI flickering when multiple items sync in quick succession
    */
   private debouncedCacheInvalidation(serviceId?: string, reason: string = 'batch_sync'): void {
     // Track the service ID (use most recent if multiple)
     if (serviceId) {
       this.pendingInvalidationServiceId = serviceId;
     }

     // Clear any existing timer
     if (this.cacheInvalidationTimer) {
       clearTimeout(this.cacheInvalidationTimer);
     }

     // Set a new timer - emit after 1 second of no new sync events
     this.cacheInvalidationTimer = setTimeout(() => {
       console.log(`[HUD DataService] Debounced cache invalidation fired (reason: ${reason})`);
       this.cacheInvalidated$.next({
         serviceId: this.pendingInvalidationServiceId,
         reason: reason
       });
       this.cacheInvalidationTimer = null;
       this.pendingInvalidationServiceId = undefined;
     }, 1000); // 1 second debounce
   }
   ```

6. **Remove old subscription properties** (around lines 46-48):
   Delete `private syncSubscription: Subscription | null = null;` and `private photoSyncSubscription: Subscription | null = null;`

  </action>
  <verify>
    - File compiles without TypeScript errors
    - `cacheInvalidated$` property exists as public Subject
    - `debouncedCacheInvalidation` method exists
    - OfflineTemplateService is imported and injected
  </verify>
  <done>HudDataService has cacheInvalidated$ Subject and debounce infrastructure matching EFE pattern</done>
</task>

<task type="auto">
  <name>Task 2: Refactor subscribeToSyncEvents with comprehensive subscriptions</name>
  <files>src/app/pages/hud/hud-data.service.ts</files>
  <action>
Replace the existing `subscribeToSyncEvents()` method with the comprehensive version that:
1. Uses `syncSubscriptions[]` array instead of individual subscription variables
2. Adds debounced emission for hudSyncComplete$
3. CRITICAL: Photo sync clears caches but does NOT emit cacheInvalidated$ (race condition prevention)
4. Adds backgroundRefreshComplete$ subscription
5. Adds imageChange$ subscription

**Replace the entire subscribeToSyncEvents method** (currently lines 95-128) with:

```typescript
/**
 * Subscribe to sync events on mobile for cache invalidation
 * When sync completes, clear relevant caches and emit cacheInvalidated$ (debounced)
 *
 * CRITICAL: Photo sync events do NOT emit cacheInvalidated$ - pages handle directly
 * to avoid race conditions with temp ID updates
 */
private subscribeToSyncEvents(): void {
  // Only subscribe on mobile
  if (!this.isMobile()) {
    return;
  }

  console.log('[HUD Data] Mobile mode - subscribing to sync events for cache invalidation');

  // Subscribe to HUD sync complete events
  this.syncSubscriptions.push(
    this.backgroundSync.hudSyncComplete$.subscribe((event: HudSyncComplete) => {
      console.log('[HUD Data] Sync complete event received:', event.operation, 'for', event.fieldKey);

      // Clear cache for the affected service
      this.hudCache.delete(event.serviceId);

      // Mark section dirty for smart reload
      const category = event.fieldKey.split(':')[1];
      if (category) {
        this.backgroundSync.markSectionDirty(`${event.serviceId}_${category}`);
      }

      // Debounced emit for page refresh
      this.debouncedCacheInvalidation(event.serviceId, 'hud_sync');
    })
  );

  // CRITICAL: Photo sync - clear caches but DO NOT emit cacheInvalidated$
  // Pages handle hudPhotoUploadComplete$ directly to avoid race conditions
  // Emitting cacheInvalidated$ here causes duplicate photos or lost captions
  this.syncSubscriptions.push(
    this.backgroundSync.hudPhotoUploadComplete$.subscribe((event: HudPhotoUploadComplete) => {
      console.log('[HUD Data] Photo synced, clearing in-memory caches only (no reload trigger)');
      this.hudAttachmentsCache.delete(event.hudId);
      this.imageCache.clear();
      // DO NOT call: this.debouncedCacheInvalidation(...);
      // The page handles hudPhotoUploadComplete$ directly for seamless UI updates
    })
  );

  // Subscribe to background refresh complete (fresh data downloaded in background)
  this.syncSubscriptions.push(
    this.offlineTemplate.backgroundRefreshComplete$.subscribe(event => {
      console.log('[HUD Data] Background refresh complete:', event.dataType, 'for', event.serviceId);

      // Clear the corresponding in-memory cache based on data type
      // HUD uses 'hud_records' and 'hud_attachments' data types
      if (event.dataType === 'visuals' || event.dataType === 'hud_records') {
        this.hudCache.delete(event.serviceId);
        console.log('[HUD Data] Cleared hudCache for', event.serviceId);
      } else if (event.dataType === 'visual_attachments' || event.dataType === 'hud_attachments') {
        this.hudAttachmentsCache.delete(event.serviceId);
        console.log('[HUD Data] Cleared hudAttachmentsCache for', event.serviceId);
      }

      // Debounced emit for page refresh
      this.debouncedCacheInvalidation(event.serviceId, `background_refresh_${event.dataType}`);
    })
  );

  // Subscribe to IndexedDB image changes (real-time UI updates when images created/updated)
  this.syncSubscriptions.push(
    this.indexedDb.imageChange$.subscribe(event => {
      console.log('[HUD Data] IndexedDB image change:', event.action, event.key, 'entity:', event.entityType, event.entityId);

      // Clear attachment caches if this is a HUD image
      if (event.entityType === 'hud') {
        this.hudAttachmentsCache.clear();
      }

      // Debounced emit for page refresh
      this.debouncedCacheInvalidation(event.serviceId, `indexeddb_${event.action}_${event.entityType}`);
    })
  );
}
```

**Also update unsubscribeFromSyncEvents** (currently lines 133-142) to use the array:

```typescript
/**
 * Unsubscribe from sync events and clear debounce timer
 */
private unsubscribeFromSyncEvents(): void {
  this.syncSubscriptions.forEach(sub => sub.unsubscribe());
  this.syncSubscriptions = [];

  if (this.cacheInvalidationTimer) {
    clearTimeout(this.cacheInvalidationTimer);
    this.cacheInvalidationTimer = null;
  }
}
```
  </action>
  <verify>
    - File compiles without TypeScript errors
    - subscribeToSyncEvents has 4 subscription blocks: hudSyncComplete$, hudPhotoUploadComplete$, backgroundRefreshComplete$, imageChange$
    - hudSyncComplete$ calls debouncedCacheInvalidation
    - hudPhotoUploadComplete$ does NOT call debouncedCacheInvalidation (only clears caches)
    - backgroundRefreshComplete$ and imageChange$ both call debouncedCacheInvalidation
    - unsubscribeFromSyncEvents clears the array and timer
  </verify>
  <done>HudDataService has comprehensive Dexie subscriptions with proper debounced emission and photo sync exception</done>
</task>

<task type="auto">
  <name>Task 3: Add invalidateCachesForService helper method</name>
  <files>src/app/pages/hud/hud-data.service.ts</files>
  <action>
Add the `invalidateCachesForService` helper method that can be called directly by pages or other services when needed. This matches the EFE pattern.

**Add after debouncedCacheInvalidation method:**

```typescript
/**
 * Invalidate all caches for a specific service
 * Called after sync to ensure fresh data is loaded from IndexedDB
 * Can also be called directly by pages when manual refresh is needed
 */
invalidateCachesForService(serviceId: string, reason: string = 'manual'): void {
  console.log(`[HUD DataService] Invalidating all caches for service ${serviceId} (reason: ${reason})`);

  // Clear service-specific caches
  this.hudCache.delete(serviceId);
  this.serviceCache.delete(serviceId);

  // Clear all attachment caches (we don't track by service)
  this.hudAttachmentsCache.clear();
  this.imageCache.clear();

  // Use debounced invalidation to batch rapid sync events
  this.debouncedCacheInvalidation(serviceId, reason);
}
```

This method:
- Provides a public API for pages to trigger cache invalidation
- Clears both HUD-specific caches and shared caches
- Uses debounced emission to prevent UI thrashing
  </action>
  <verify>
    - File compiles without TypeScript errors
    - `invalidateCachesForService` method exists and is public
    - Method clears hudCache, serviceCache, hudAttachmentsCache, imageCache
    - Method calls debouncedCacheInvalidation
  </verify>
  <done>HudDataService has public invalidateCachesForService method for manual cache invalidation</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **TypeScript compilation:**
   - File compiles without errors

2. **Pattern verification:**
   ```bash
   # Verify cacheInvalidated$ exists
   grep -n "cacheInvalidated\$" src/app/pages/hud/hud-data.service.ts

   # Verify debouncedCacheInvalidation exists
   grep -n "debouncedCacheInvalidation" src/app/pages/hud/hud-data.service.ts

   # Verify OfflineTemplateService injection
   grep -n "OfflineTemplateService" src/app/pages/hud/hud-data.service.ts

   # Verify backgroundRefreshComplete subscription
   grep -n "backgroundRefreshComplete" src/app/pages/hud/hud-data.service.ts

   # Verify imageChange subscription
   grep -n "imageChange\$" src/app/pages/hud/hud-data.service.ts

   # Verify photo sync does NOT emit cacheInvalidated
   grep -A5 "hudPhotoUploadComplete" src/app/pages/hud/hud-data.service.ts | grep -v "debouncedCacheInvalidation"
   ```

3. **Critical pattern check:**
   - Photo sync block must have comment explaining WHY it doesn't emit cacheInvalidated$
   - All other sync blocks must call debouncedCacheInvalidation
</verification>

<success_criteria>
Phase 2 requirements satisfied:

- [x] DATA-01: HudDataService has cache invalidation Subject (`cacheInvalidated$`)
- [x] DATA-02: HudDataService has debounced sync events (`debouncedCacheInvalidation` with 1s timeout)
- [x] DATA-03: HudDataService has comprehensive Dexie subscriptions (hudSyncComplete$, hudPhotoUploadComplete$, backgroundRefreshComplete$, imageChange$)
- [x] DATA-04: HudDataService coordinates refresh across components (via cacheInvalidated$ that pages subscribe to)

All observable truths from must_haves are achievable.
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-service-enhancement/02-01-SUMMARY.md`
</output>
