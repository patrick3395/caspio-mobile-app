---
phase: 07-hud-category-detail
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/pages/hud/hud-category-detail/hud-category-detail.page.ts
autonomous: true

must_haves:
  truths:
    - "HUD page loads templates from LPS_Services_HUD_Templates (TypeID=2)"
    - "Template loading uses ensureHudTemplatesReady() not getVisualsTemplates()"
    - "Categories display correct number of items matching HUD templates"
  artifacts:
    - path: "src/app/pages/hud/hud-category-detail/hud-category-detail.page.ts"
      provides: "HUD template loading"
      contains: "ensureHudTemplatesReady"
  key_links:
    - from: "hud-category-detail.page.ts"
      to: "offlineTemplate.ensureHudTemplatesReady()"
      via: "loadDataFromAPI method"
      pattern: "ensureHudTemplatesReady\\(\\)"
---

<objective>
Fix HUD category-detail template loading path to use HUD templates (TypeID=2) instead of EFE visual templates (TypeID=1).

Purpose: The current implementation calls `hudData.getVisualsTemplates()` which loads EFE templates from LPS_Services_Visuals_Templates. HUD pages must use `offlineTemplate.ensureHudTemplatesReady()` which loads from LPS_Services_HUD_Templates.

Output: hud-category-detail.page.ts loading correct HUD templates
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-hud-category-detail/07-RESEARCH.md

@src/app/pages/hud/hud-category-detail/hud-category-detail.page.ts
@src/app/services/offline-template.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace getVisualsTemplates with ensureHudTemplatesReady</name>
  <files>src/app/pages/hud/hud-category-detail/hud-category-detail.page.ts</files>
  <action>
In the `loadDataFromAPI()` method (around line 714), change:

```typescript
// CURRENT (WRONG):
const [templates, visuals] = await Promise.all([
  this.hudData.getVisualsTemplates(),
  this.hudData.getVisualsByService(this.serviceId)
]);
```

TO:

```typescript
// CORRECTED (HUD templates):
const [templates, visuals] = await Promise.all([
  this.offlineTemplate.ensureHudTemplatesReady(),
  this.hudData.getVisualsByService(this.serviceId)
]);
```

This change:
- Loads templates from LPS_Services_HUD_Templates (TypeID=2) instead of LPS_Services_Visuals_Templates (TypeID=1)
- Uses the same Dexie-first pattern with 24-hour TTL caching
- Handles both WEBAPP (network-first) and MOBILE (Dexie-first) modes

The `offlineTemplate` service is already injected in the constructor, so no import changes are needed.

Also search for any other occurrences of `getVisualsTemplates` in this file and update them similarly if found (grep shows only line 714).
  </action>
  <verify>
Grep the file to confirm:
1. No remaining calls to `getVisualsTemplates`
2. `ensureHudTemplatesReady` is now called in loadDataFromAPI
  </verify>
  <done>
loadDataFromAPI() calls offlineTemplate.ensureHudTemplatesReady() to load HUD templates (TypeID=2)
  </done>
</task>

<task type="auto">
  <name>Task 2: Update template matching to handle HUD field names</name>
  <files>src/app/pages/hud/hud-category-detail/hud-category-detail.page.ts</files>
  <action>
In the template matching logic within `loadDataFromAPI()` (around lines 756-771), the code matches visuals to templates using `VisualTemplateID`. HUD templates may use `HUDTemplateID` or `TemplateID`. Update the matching logic:

```typescript
// CURRENT:
let visual = (visuals || []).find((v: any) => {
  const vTemplateId = v.VisualTemplateID || v.TemplateID;
  return vTemplateId == templateId && v.Category === this.categoryName;
});
```

TO:

```typescript
// CORRECTED (HUD field names):
let visual = (visuals || []).find((v: any) => {
  const vTemplateId = v.HUDTemplateID || v.VisualTemplateID || v.TemplateID;
  return vTemplateId == templateId && v.Category === this.categoryName;
});
```

This ensures the matching works with HUD records that use `HUDTemplateID` as the template reference field.

Search for other occurrences of `VisualTemplateID` in the file and add `HUDTemplateID ||` fallback where appropriate (same pattern for template matching).
  </action>
  <verify>
Grep the file to confirm:
1. Template matching includes HUDTemplateID fallback
2. No orphaned VisualTemplateID-only references in template matching logic
  </verify>
  <done>
Template matching uses HUDTemplateID || VisualTemplateID || TemplateID fallback chain
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. Grep for getVisualsTemplates - should return 0 results
2. Grep for ensureHudTemplatesReady - should return at least 1 result in loadDataFromAPI
3. Grep for HUDTemplateID - should return at least 1 result in template matching

```bash
grep -c "getVisualsTemplates" src/app/pages/hud/hud-category-detail/hud-category-detail.page.ts
# Expected: 0

grep -c "ensureHudTemplatesReady" src/app/pages/hud/hud-category-detail/hud-category-detail.page.ts
# Expected: >= 1

grep -c "HUDTemplateID" src/app/pages/hud/hud-category-detail/hud-category-detail.page.ts
# Expected: >= 1
```
</verification>

<success_criteria>
- [ ] loadDataFromAPI() calls ensureHudTemplatesReady() instead of getVisualsTemplates()
- [ ] Template matching includes HUDTemplateID in the fallback chain
- [ ] No remaining references to getVisualsTemplates in the file
</success_criteria>

<output>
After completion, create `.planning/phases/07-hud-category-detail/07-01-SUMMARY.md`
</output>
