---
phase: 07-hud-category-detail
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/pages/hud/hud-data.service.ts
  - src/app/services/offline-template.service.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "HUD category-detail loads records from LPS_Services_HUD table, not LPS_Services_Visuals"
    - "getHudByService() method exists and queries correct HUD table"
  artifacts:
    - path: "src/app/pages/hud/hud-data.service.ts"
      provides: "getHudByService() method for HUD record loading"
      contains: "getHudByService"
    - path: "src/app/services/offline-template.service.ts"
      provides: "getServicesHUDByServiceId wrapper with cache-first pattern"
      contains: "getHudByService"
  key_links:
    - from: "hud-data.service.ts"
      to: "LPS_Services_HUD via caspio.service"
      via: "getServicesHUDByServiceId()"
      pattern: "getServicesHUDByServiceId"
---

<objective>
Create getHudByService() method to load HUD records from LPS_Services_HUD table

Purpose: HUD category-detail currently calls getVisualsByService() which queries LPS_Services_Visuals (EFE table) instead of LPS_Services_HUD. This is a critical data source bug.

Output: New getHudByService() method in hud-data.service.ts that queries the correct HUD table
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-hud-category-detail/07-VERIFICATION.md
@src/app/pages/hud/hud-data.service.ts
@src/app/services/offline-template.service.ts
@src/app/services/caspio.service.ts (line 1775: getServicesHUDByServiceId already exists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getHudByService to offline-template.service.ts</name>
  <files>src/app/services/offline-template.service.ts</files>
  <action>
Add a new method getHudByService() following the EXACT pattern of getVisualsByService() (lines 1429-1478).

Place it after getVisualsByService() method. The implementation should:

1. WEBAPP MODE (environment.isWeb): Call caspioService.getServicesHUDByServiceId(serviceId) directly
2. MOBILE MODE: Cache-first pattern with 'hud' cache type:
   - Read from cache: indexedDb.getCachedServiceData(serviceId, 'hud')
   - Merge with pending HUD records from queue
   - Background refresh when online
   - Fall back to API if cache empty

```typescript
/**
 * Get HUD records for a service - CACHE-FIRST for instant loading
 * Returns cached data immediately, refreshes in background when online
 *
 * WEBAPP MODE (isWeb=true): Always fetches from API to show synced data from mobile
 */
async getHudByService(serviceId: string): Promise<any[]> {
  // WEBAPP MODE: Always fetch from API to see synced data from mobile
  if (environment.isWeb) {
    console.log(`[OfflineTemplate] WEBAPP MODE: Fetching HUD records directly from API for ${serviceId}`);
    try {
      const freshHud = await firstValueFrom(this.caspioService.getServicesHUDByServiceId(serviceId));
      console.log(`[OfflineTemplate] WEBAPP: Loaded ${freshHud?.length || 0} HUD records from server`);
      return freshHud || [];
    } catch (error) {
      console.error(`[OfflineTemplate] WEBAPP: API fetch failed for HUD records:`, error);
      return [];
    }
  }

  // MOBILE MODE: Cache-first pattern
  // 1. Read from cache IMMEDIATELY
  const cached = await this.indexedDb.getCachedServiceData(serviceId, 'hud') || [];

  // 2. Merge with pending offline HUD records (if any in queue)
  const pending = await this.getPendingHudRecords(serviceId);
  const merged = [...cached, ...pending];

  // 3. Return immediately if we have data
  if (merged.length > 0) {
    console.log(`[OfflineTemplate] HUD: ${cached.length} cached + ${pending.length} pending (instant)`);

    // 4. Background refresh (non-blocking) when online
    if (this.offlineService.isOnline()) {
      this.refreshHudInBackground(serviceId);
    }
    return merged;
  }

  // 5. Cache empty - fetch from API if online (blocking only when no cache)
  if (this.offlineService.isOnline()) {
    try {
      console.log(`[OfflineTemplate] No cached HUD records, fetching from API...`);
      const freshHud = await firstValueFrom(this.caspioService.getServicesHUDByServiceId(serviceId));
      await this.indexedDb.cacheServiceData(serviceId, 'hud', freshHud);
      return [...freshHud, ...pending];
    } catch (error) {
      console.error(`[OfflineTemplate] HUD API fetch failed:`, error);
    }
  }

  // 6. Offline with no cache - return pending only
  console.log(`[OfflineTemplate] Offline with no HUD cache, returning ${pending.length} pending`);
  return pending;
}

/**
 * Get pending HUD records from operations queue for a service
 */
private async getPendingHudRecords(serviceId: string): Promise<any[]> {
  // Similar to getPendingVisuals but for HUD entity type
  // For now, return empty array - HUD queue integration can be added later
  return [];
}

/**
 * Background refresh HUD records (non-blocking)
 */
private async refreshHudInBackground(serviceId: string): Promise<void> {
  try {
    const freshHud = await firstValueFrom(this.caspioService.getServicesHUDByServiceId(serviceId));
    await this.indexedDb.cacheServiceData(serviceId, 'hud', freshHud);
    console.log(`[OfflineTemplate] Background HUD refresh complete: ${freshHud?.length || 0} records`);
  } catch (error) {
    console.warn(`[OfflineTemplate] Background HUD refresh failed (non-blocking):`, error);
  }
}
```
  </action>
  <verify>
grep -n "getHudByService" src/app/services/offline-template.service.ts
# Should return method definition and references
grep -n "getServicesHUDByServiceId" src/app/services/offline-template.service.ts
# Should return calls to caspio service method
  </verify>
  <done>
- getHudByService() method added to offline-template.service.ts
- Method follows identical cache-first pattern as getVisualsByService()
- WEBAPP mode calls caspioService.getServicesHUDByServiceId() directly
- MOBILE mode uses 'hud' cache type with background refresh
  </done>
</task>

<task type="auto">
  <name>Task 2: Add getHudByService wrapper to hud-data.service.ts</name>
  <files>src/app/pages/hud/hud-data.service.ts</files>
  <action>
Add a getHudByService() method that delegates to offlineTemplate.getHudByService().

Find the existing getVisualsByService() method (which currently delegates to offlineTemplate.getVisualsByService()) and add a parallel method for HUD:

```typescript
/**
 * Get HUD records for a service - delegates to OfflineTemplateService
 * Queries LPS_Services_HUD table (not LPS_Services_Visuals)
 */
async getHudByService(serviceId: string): Promise<any[]> {
  return this.offlineTemplate.getHudByService(serviceId);
}
```

Place this near the existing getVisualsByService() method for code organization.
  </action>
  <verify>
grep -n "getHudByService" src/app/pages/hud/hud-data.service.ts
# Should return method definition
  </verify>
  <done>
- getHudByService() method added to hud-data.service.ts
- Method delegates to offlineTemplate.getHudByService()
- Ready to be called by hud-category-detail.page.ts
  </done>
</task>

</tasks>

<verification>
1. grep for 'getHudByService' in both service files - should return method definitions
2. grep for 'getServicesHUDByServiceId' in offline-template.service.ts - should return caspio calls
3. TypeScript compiles without errors
</verification>

<success_criteria>
- getHudByService() exists in both hud-data.service.ts and offline-template.service.ts
- Method queries LPS_Services_HUD table via caspioService.getServicesHUDByServiceId()
- Cache-first pattern uses 'hud' cache type for MOBILE mode
</success_criteria>

<output>
After completion, create `.planning/phases/07-hud-category-detail/07-04-SUMMARY.md`
</output>
